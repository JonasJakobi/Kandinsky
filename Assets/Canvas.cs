
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
/// <summary>
///Main Script, creates kadinsky shapes making sure they follow the 'rules', constructs them into gameobjects, and takes a screenshot once the scene is finished. 
/// </summary>
public class Canvas : MonoBehaviour
{

    
    [Header("Constants and Variables to Tweak")]
    public int positionIndex = 0;
    public int amountOfShapes = 5;
    
    public float minSize = 0.5f;
  
    public float maxSize = 2f;
    CanvasBounds defaultBounds = new CanvasBounds(-5, 5, -5, 5);
    [SerializeField]
    [Tooltip("How many tries we give every shape to fullfill all of its rules.")]
    public int maxTriesShape = 450;
    [SerializeField]
    //if a shape fails, the whole canvas will try again. This is how many tries it has before the program terminats without a result.
    [Tooltip("How many tries we give the entire canvas to try again.")]
    public int maxTriesCanvas = 5;


    public List<(ShapeType, ColorType)> MandatoryShapes = new ();
    
    public ShapeRule[] rules;
   
    
 

    [Header("Drawing 'Ressources'. Add new Shapes and Colors here. (Also edit enums in KadinskyShape.cs)")]

    [Tooltip("0 Square, 1 Triangle, 2 Circle, 3 Hexagon")]
    [SerializeField]
    GameObject[] shapeObjects;
    [Tooltip("0 Red, 1 Green, 2 Blue, 3 Yellow")]
    [SerializeField]
    Color[] colors;

    [Header("Visibible for debugging")]
    [SerializeField]
    /// <summary>
    /// List of all current shapes. Generated by calling TryGenerateShapes(). To get image, call DrawShapes(), will fill instantiatedShapes with gameobjects corresponding to allShapes.
    /// </summary>
    public List<KadinskyShape> allShapes;
    [SerializeField]
    List<GameObject> instantiatedShapes;

  

    /// <summary>
    /// Highest level method for generation.
    /// Generates kadinsky shapes and fills in "allShapes".
    /// </summary>
    /// <param name="amountOfShapes"></param>
    /// <param name="rulesApply">true - All rules specified in 'rules' will have to be all true.
    ///                          false - All rules have to be false / not apply. 
    ///                          </param>
    public void TryGenerateShapes(int amountOfShapes, bool rulesApply)
    {
        int tries = 0;
        while (!GenerateShapes(amountOfShapes, rulesApply))
        {
            Debug.Log("Failed to generate image. Trying again. Try number: " + tries);
            if (tries > maxTriesCanvas)
            {
                Debug.Log("All tries failed to generate an image. Rules might be impossible or very unlikely. Otherwise contact maintainer to fix the program logic.");
                return;
            }
            tries++;
        }
    }
    /// <summary>
    /// Called by TryGenerate, ecanpsuled to allow for multiple tries.
    /// </summary>
    private bool GenerateShapes(int amountOfShapes, bool rulesApply)
    {
        //Create new array or clear old one.
        if (allShapes == null)
        {
            allShapes = new List<KadinskyShape>();
        }
        else
        {
            allShapes.Clear();
        }
        int mandatoryShapeIndex = 0;
        GenerateMandatoryShapes();


        for (int i = 0; i < amountOfShapes; i++)
        {
            bool isMandatoryShape = false;
            //We try to brute force the applied rules with randomness. set a maximum limit of tries ( maxTriesShape ), to make sure program doesnt get stuck. 
            int tries = 0;
            KadinskyShape shape = null;
            bool validShapeAndColor = false;
            bool validPosition = false;
            //As long as we havent created a valid shape yet, we keep trying, checking tho if we have reached our maximum try amount, as the shape might be impossible due to rule conflicts.
            while (!validShapeAndColor || !validPosition)
            {
                
                //if we exceed maximum tries we start again with new canvas. 
                if (tries > maxTriesShape)
                {
                    Debug.LogError("Could not create shape with rules! check rule for why this wasnt possible. ");
                    LogAllShapes();
                    return false;
                }
                //If we dont have a valid shape and color yet, we first generate that, and stop randomizing that once we have it.
                if (!validShapeAndColor)
                {
                    if(mandatoryShapeIndex < MandatoryShapes.Count)
                    {
                        //get shape and color from mandatory
                        shape = CreateMandatoryShape(mandatoryShapeIndex);
                        isMandatoryShape = true;
                        print("Creating mandatory shape!" + shape.ToString());
                    }
                    else
                    {
                        shape = CreateRandomShape();
                        isMandatoryShape = false;
                    }
                    
                    validShapeAndColor = CheckRules(shape, rulesApply, false);
                }
                else //instead, if we already have a valid shape and color, we only check the position.
                {
                    shape.position = GenerateRandomPositionAnywhere();
                    validPosition = !CheckColliding(shape) && CheckRules(shape, rulesApply, true);
                }
                
                tries++;
            }
            //If we get here, we have a valid shape. Add it to the list.
            allShapes.Add(shape);
            if (isMandatoryShape)
            {
                mandatoryShapeIndex++;
            }
            
        }
        //If we get here, we have a valid canvas.
        return true;
    }
    /// <summary>
    /// Chekcs if the 'shape' would collide with any of the shapes in 'allShapes'.
    /// </summary>
    /// <param name="shape">The shape to check for</param>
    /// <returns>true if it is colliding (so the shape is not valid</returns>
    private bool CheckColliding(KadinskyShape shape)
    {
        foreach (KadinskyShape otherShape in allShapes)
        {
            //Check collisions only by position and size in both x and y direction and with some padding
            if (shape.position.x + shape.size > otherShape.position.x && shape.position.x < otherShape.position.x + otherShape.size)
            {
                if (shape.position.y + shape.size > otherShape.position.y && shape.position.y < otherShape.position.y + otherShape.size)
                {
                    return true;
                }
            }

        }
        return false;
    }
    /// <summary>
    /// Creates a random shape and checks:
    /// -If it intersects with another existing shape
    /// -all rules if they apply / do not apply.
    /// </summary>
    /// <param name="rulesApply">true - all rules need to apply. false- all rules may not apply</param>
    /// <param name="afterShapeAndColor">false- if shape is valid, we now have a correct shape and color, true- if the shape is valid, we now have a correct position.</param>
    /// <returns>true if the shape is valid, false if not.</returns>
    private bool CheckRules(KadinskyShape shape, bool rulesApply, bool afterShapeAndColor)
    {
        
        foreach (ShapeRule rule in rules)
        {
            
            if (!rule.AppliesTo(shape) && afterShapeAndColor) continue; //go to next rule if this one doesnt apply after choosing shape and color. (amount rules behaviour is tricky, see shaperule.cs)
            RulesResult result;
            //check rules that we check only to determine position , so shape and color is already set:
            if (afterShapeAndColor)
            {
                result = rule.checkRulesAfterShapeAndColor(allShapes, shape);
            }
            else // check rules to determine shape and color (check ShapeRule for in depth explanation why this is neccessary)
            {
                result = rule.checkRulesBeforeShapeAndColor(allShapes, shape);
            }
            //it is valid if:
            //-Rule should be followed and it does,
            //-it shouldnt be followed and it doesnt.
            //-"None" which means the rule never had to be checked / validated. (so its also valid.)
            //So, if its NOT all of the above, we return false. (it has to be formatted like this as a single violation should instantly return false.)
            if (!((rulesApply && result.Equals(RulesResult.AllTrue)) || (!rulesApply && result.Equals(RulesResult.AllFalse)) || result.Equals(RulesResult.None))) 
            {
                return false;
            }
        }

        return true;
    }
    /// <summary>
    /// Creates all gameobjects for every KadinskyShape. 
    /// </summary>
    /// <param name="nr"></param>
    public void DrawShapes()
    {
        //Create a new List or destroy and clear old one.
        if (instantiatedShapes == null)
        {
            instantiatedShapes = new List<GameObject>();
        }
        else
        {
            foreach (GameObject go in instantiatedShapes)
            {
                Destroy(go);
            }
            instantiatedShapes.Clear();
        }

        //Construct a new gameobject for every shape.
        foreach (KadinskyShape shape in allShapes)
        {
            GameObject go = Instantiate(shapeObjects[(int)shape.shape]);
            go.GetComponent<SpriteRenderer>().color = colors[(int)shape.color];
            go.transform.localScale = new Vector3(shape.size, shape.size, shape.size);
            Vector3 position = transform.position + new Vector3(shape.position.x, shape.position.y, 0);
            go.transform.position = position;
            instantiatedShapes.Add(go);
        }
       
    }

   public KadinskyShape CreateMandatoryShape(int index)
    {
        KadinskyShape shape = new KadinskyShape();
        
        shape.shape = MandatoryShapes[index].Item1;
        if (shape.shape.Equals(ShapeType.AllShapes))
        {
            shape.shape = (ShapeType)Random.Range(0, System.Enum.GetValues(typeof(ShapeType)).Length - 1);
        }
        shape.color = MandatoryShapes[index].Item2;
        if (shape.color.Equals(ColorType.AllColors))
        {
            shape.color = (ColorType)Random.Range(0, System.Enum.GetValues(typeof(ColorType)).Length - 1);
        }
        shape.size = Random.Range(minSize, maxSize);
        shape.position = GenerateRandomPositionAnywhere();
        return shape;
    }

    
    public KadinskyShape CreateRandomShape()
    {
        
        KadinskyShape shape = new KadinskyShape();
        shape.shape = (ShapeType)Random.Range(0, System.Enum.GetValues(typeof(ShapeType)).Length - 1); // -1 because we dont want the "AllShapes" type
        shape.color = (ColorType)Random.Range(0, System.Enum.GetValues(typeof(ColorType)).Length - 1); // -1 because we dont want the "AllColors" type
        shape.size = Random.Range(minSize, maxSize);
        shape.position = GenerateRandomPositionAnywhere();
        return shape;
    }
    public Vector2 GenerateRandomPositionInsideBounds(CanvasBounds bounds)
    {
        float padding = maxSize / 2;
        // Generate a random position inside the bounds of the canvas
        float randomX = Random.Range(bounds.minX + padding, bounds.maxX - padding);
        float randomY = Random.Range(bounds.minY + padding, bounds.maxY - padding);
        Vector3 randomPosition = new Vector3(randomX, randomY, 0);
        return randomPosition;
    }
    public Vector2 GenerateRandomPositionAnywhere()
    {

        return GenerateRandomPositionInsideBounds(defaultBounds);
    }



    private void LogAllShapes()
    {
        Debug.Log("Canvas with " + allShapes.Count + " shapes: ");
        foreach (KadinskyShape shape in allShapes)
        {

            Debug.Log(shape.ToString());
        }

    }
    public void GenerateMandatoryShapes()
    {
        MandatoryShapes = new List<(ShapeType, ColorType)>();
        
        foreach(var rule in rules)
        {
            if (rule.maxAmountRule || rule.minAmountRule) continue;
            MandatoryShapes.Add((rule.shapeType, rule.color));
            print("mandatory shape generated: " + rule.shapeType + rule.color);
        }
    }

    /// <summary>
    /// Checks if there is a positional rule like x has to be below y. In this case, make the space in which y can generate smaller.
    /// THIS IS AN IDEA AND NOT YET IMPLEMENTED. TODO implement for more efficiency, should even more rules start to make problems with runtime / amount of tries. 
    /// </summary>
    private void CheckPositionalRulesForRestriction(KadinskyShape checkBeforePlacing)
    {
        foreach (ShapeRule rule in rules)
        {
            if (rule.positionRules)
            {
                //Take shape it effects, adjust its bounds by using FindAllShapeAndColor and then Utils.FindLargest and substract from Bounds to create new bounds.

            }

        }
    }
    public KadinskyShape[] FindAllOfShapeAndColor(ShapeType shape, ColorType color)
    {
        List<KadinskyShape> shapes = new List<KadinskyShape>();
        foreach (KadinskyShape s in allShapes)
        {
            if (Utils.AreShapesEqual(s.shape, shape) && Utils.AreColorsEqual(s.color, color))
            {
                shapes.Add(s);
            }
        }
        return shapes.ToArray();
    }

}
[System.Serializable]
public struct CanvasBounds{
    public float minX;
    public float maxX;
    public float minY;
    public float maxY;
    /// <summary>
    /// Bounds of the canvas. MIN VALUES HAVE TO BE NEGATIVE or in other words, center is always 0,0.
    /// </summary>
    /// <param name="minX"></param>
    /// <param name="maxX"></param>
    /// <param name="minY"></param>
    /// <param name="maxY"></param>
    public CanvasBounds(float minX, float maxX, float minY, float maxY) : this()
    {
        this.minX = minX;
        this.maxX = maxX;
        this.minY = minY;
        this.maxY = maxY;
    }


   
}
